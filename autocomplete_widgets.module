<?php
// $Id$

/**
 * @file
 * Provides autocomplete widgets for CCK Text and Number fields.
 */

/**
 * Implementation of hook_menu().
 */
function autocomplete_widgets_menu() {
  $items = array();
  $items['autocomplete_widgets'] = array(
    'title' => 'Autocomplete Widgets',
    'page callback' => 'autocomplete_widgets_json',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implementation of hook_theme().
 */
function autocomplete_widgets_theme() {
  return array(
    'autocomplete_widgets' => array('arguments' => array('element' => NULL)),
  );
}

/**
 * Implementation of hook_form_alter().
 *
 * Because we need to alter the field settings form, this module needs
 * to be loaded after CCK Text/Number field modules.
 * See autocomplete_widgets_install().
 */
function autocomplete_widgets_form_alter(&$form, $form_state, $form_id) {
  // Provide additional help for the field settings form.
  if ($form_id == 'content_field_edit_form' && isset($form['widget'])) {
    $widget_type = $form['#field']['widget']['type'];
    if (in_array($widget_type, array('autocomplete_widgets_allowvals', 'autocomplete_widgets_flddata'))) {
      // Implementation of allowed values list.
      if ($widget_type == 'autocomplete_widgets_allowvals') {
        $form['field']['allowed_values_fieldset']['#collapsed'] = FALSE;
        $form['field']['allowed_values_fieldset']['#description'] = '<p>'. t('Create a list of options as a list in <strong>Allowed values list</strong> or as an array in PHP code. These values will be the same for %field in all content types.', array('%field' => t($form['#field']['widget']['label']))) .'</p>';

        // If no 'allowed values' were set yet, add a remainder in the messages area.
        if (empty($form_state['post'])
        && empty($form['field']['allowed_values_fieldset']['allowed_values']['#default_value'])
        && empty($form['field']['allowed_values_fieldset']['advanced_options']['allowed_values_php']['#default_value'])) {
          drupal_set_message(t("You need to specify the 'allowed values' for this field."), 'warning');
        }
      }
      else {
        // For the autocomplete 'field data' widget we do not use the 'Allowed values' list.
        unset($form['field']['allowed_values_fieldset']);
      }
      // Disable the text processing option of text fields. These widgets can
      // only use plain text fields.
      if (isset($form['field']['text_processing'])) {
        $form['field']['text_processing']['#type'] = 'value';
        $form['field']['text_processing']['#value'] = 0;
      }
    }
  }
}

/**
 * Implementation of hook_widget_info().
 */
function autocomplete_widgets_widget_info() {
  return array(
    'autocomplete_widgets_allowvals' => array(
      'label' => t('Autocomplete for allowed values list'), 'field types' => array('text', 'number_integer', 'number_decimal', 'number_float'),
    ),
    'autocomplete_widgets_flddata' => array(
      'label' => t('Autocomplete for existing field data'), 'field types' => array('text'),
    ),
  );
}

/**
 * Implementation of hook_elements().
 *
 * Autocomplete_path is not used by text_widget but other widgets can use it
 * (see nodereference and userreference).
 */
function autocomplete_widgets_elements() {
  return array(
    'autocomplete_widgets' => array(
      '#input' => TRUE,
      '#columns' => array('value'), '#delta' => 0,
      '#process' => array('autocomplete_widgets_process'),
      '#autocomplete_path' => FALSE,
    ),
  );
}

/**
 * Implementation of hook_widget_settings().
 */
function autocomplete_widgets_widget_settings($op, $widget) {
  switch ($op) {
    case 'form':
      $form = array();
      $form['size'] = array(
        '#type' => 'textfield',
        '#title' => t('Size of textfield'),
        '#default_value' => (isset($widget['size']) ? $widget['size'] : 60),
        '#element_validate' => array('_element_validate_integer_positive'),
        '#required' => TRUE,
      );
      $form['autocomplete_match'] = array(
        '#type' => 'select',
        '#title' => t('Autocomplete matching'),
        '#default_value' => (isset($widget['autocomplete_match']) ? $widget['autocomplete_match'] : 'contains'),
        '#options' => array('starts_with' => t('Starts with'), 'contains' => t('Contains')),
        '#description' => t('Select the method used to collect autocomplete suggestions. Note that <em>Contains</em> can cause performance issues on sites with thousands of records.'),
      );
      $form['autocomplete_case'] = array(
        '#type' => 'radios',
        '#title' => t('Case sensitive'),
        '#default_value' => (isset($widget['autocomplete_case']) ? $widget['autocomplete_case'] : 1),
        '#options' => array(0 => t('Disabled'), 1 => t('Enabled')),
      );
      if ($widget['type'] == 'autocomplete_widgets_flddata') {
        $form['autocomplete_case']['#description'] = t('Case-insensitive queries are implemented using the <a href="!function-lower-url">LOWER()</a> function in combination with the <a href="!operator-like-url">LIKE</a> operator.', array(
          '!function-lower-url' => 'http://dev.mysql.com/doc/refman/5.1/en/string-functions.html#function_lower',
          '!operator-like-url' => 'http://dev.mysql.com/doc/refman/5.1/en/string-comparison-functions.html#operator_like',
        ));
        if (in_array($GLOBALS['db_type'], array('mysql', 'mysqli'))) {
          $form['autocomplete_case']['#description'] .= ' '. t('Note that MySQL might ignore case sensitivity depending on the collation used in your database definition (see <a href="!mysql-i18n-l10n-url">Internationalization and Localization</a> chapter in the MySQL manual). If you need case insensitive checks, it is recommended (for performance reasons) to use a case insensitive collation as well (such as utf8_general_ci), rather than disabling the case sensitive option here.', array(
            '!mysql-i18n-l10n-url' => 'http://dev.mysql.com/doc/refman/5.1/en/internationalization-localization.html',
          ));
        }
        elseif ($GLOBALS['db_type'] == 'pgsql') {
          $form['autocomplete_case']['#description'] .= ' '. t('You may want to create an expression index using the LOWER() function to speed up this kind of queries in PostgreSQL (See <a href="!indexes-expressional-url">Indexes on Expressions</a>).', array(
            '!indexes-expressional-url' => 'http://www.postgresql.org/docs/8.4/static/indexes-expressional.html',
          ));
        }
      }
      else {
        $form['autocomplete_case']['#description'] = t('Case-insensitive queries are implemented using the function <a href="!drupal-strtolower-url">drupal_strtolower()</a>.', array(
          '!drupal-strtolower-url' => 'http://api.drupal.org/api/function/drupal_strtolower/6',
        ));
      }
      if ($widget['type'] == 'autocomplete_widgets_flddata' && module_exists('i18n')) {
        $form['i18n_flddata'] = array(
          '#type' => 'radios',
          '#title' => t('Internationalization support'),
          '#default_value' => (isset($widget['i18n_flddata']) ? $widget['i18n_flddata'] : 0),
          '#options' => array(0 => t('Disabled'), 1 => t('Enabled')),
          '#description' => t('Enable this option to provide a different set of allowed values based on the language their nodes are assigned to. This option is only available when <a href="@i18n-project-page">Internationalization</a> module is enabled.', array('@i18n-project-page' => 'http://drupal.org/project/i18n')),
        );
      }
      else {
        $form['i18n_flddata'] = array(
          '#type' => 'value',
          '#value' => 0,
        );
      }
      return $form;

    case 'save':
      return array('size', 'autocomplete_match', 'autocomplete_case', 'i18n_flddata');
  }
}

/**
 * Implementation of hook_widget().
 */
function autocomplete_widgets_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  return array(
    '#type' => 'autocomplete_widgets',
    '#default_value' => isset($items[$delta]) ? $items[$delta] : NULL,
  );
}

/**
 * Process an individual textfield autocomplete element.
 */
function autocomplete_widgets_process($element, $edit, $form_state, $form) {
  $field = $form['#field_info'][$element['#field_name']];
  $field_key = $element['#columns'][0];

  $value = NULL;
  if ($field['widget']['type'] == 'autocomplete_widgets_allowvals') {
    if (isset($element['#value'][$field_key])) {
      $keys = array($element['#value'][$field_key]);
      $options = _autocomplete_widgets_get_options($field, '', '', $keys, 1);
      if (!empty($options)) {
        $value = current($options);
      }
    }
  }
  else if ($field['widget']['type'] == 'autocomplete_widgets_flddata') {
    if (isset($element['#value'][$field_key])) {
      $value = $element['#value'][$field_key];
    }
  }

  $element[$field_key] = array(
    '#type' => 'textfield',
    '#default_value' => $value,
    '#autocomplete_path' => 'autocomplete_widgets/'. $element['#type_name'] .'/'. $element['#field_name'],
    '#size' => !empty($field['widget']['size']) ? $field['widget']['size'] : 60,
    '#attributes' => array('class' => 'text'),
    // The following values were set by the content module and need
    // to be passed down to the nested element.
    '#title' => $element['#title'],
    '#description' => $element['#description'],
    '#required' => $element['#required'],
    '#field_name' => $element['#field_name'],
    '#type_name' => $element['#type_name'],
    '#delta' => $element['#delta'],
    '#columns' => $element['#columns'],
  );

  $element[$field_key]['#maxlength'] = !empty($field['max_length']) ? $field['max_length'] : NULL;

  if (empty($element[$field_key]['#element_validate'])) {
    $element[$field_key]['#element_validate'] = array();
  }
  array_unshift($element[$field_key]['#element_validate'], 'autocomplete_widgets_validate');

  $element['_error_element'] = array(
    '#type' => 'value',
    '#value' => implode('][', array_merge($element['#parents'], array($field_key))),
  );

  return $element;
}

/**
 * Validate a textfield autocomplete element.
 */
function autocomplete_widgets_validate($element, &$form_state) {
  $field_name = $element['#field_name'];
  $type_name = $element['#type_name'];
  $delta = $element['#delta'];
  $field = content_fields($field_name, $type_name);
  $field_key = $element['#columns'][0];
  $value = trim($element['#value']);

  if ($field['widget']['type'] == 'autocomplete_widgets_allowvals') {
    if ($value !== '') {
      $options = _autocomplete_widgets_get_options($field, $value, 'equals', NULL, 1);
      if (empty($options)) {
        form_error($element, t('%name: found no valid option.', array('%name' => t($field['widget']['label']))));
      }
      else {
        $value = key($options);
      }
    }
  }

  // Remove the wrapper layer and set the right element's value.
  // This will move the nested value at 'field-name-0-value-value'
  // back to its original location, 'field-name-0-value'.
  form_set_value($element, $value, $form_state);
}

/**
 * Menu callback; Retrieve a pipe delimited string of autocomplete suggestions.
 */
function autocomplete_widgets_json($type_name, $field_name, $string = '') {
  $field = content_fields($field_name, $type_name);
  $match = isset($field['widget']['autocomplete_match']) ? $field['widget']['autocomplete_match'] : 'contains';
  $matches = array();
  $options = _autocomplete_widgets_get_options($field, $string, $match, NULL, 10);
  foreach ($options as $key => $value) {
    // Add a class wrapper for a few required CSS overrides.
    $matches[$value] = '<div class="reference-autocomplete">'. check_plain($value) .'</div>';
  }
  drupal_json($matches);
}

/**
 * Fetch an array of options for the given widget.
 *
 * @param $field
 *   The field description.
 * @param $string
 *   Optional string to filter values on (used by autocomplete).
 * @param $match
 *   Operator to match filtered name against, can be any of:
 *   'contains', 'equals', 'starts_with'
 * @param $keys
 *   Optional keys to lookup (the $string and $match arguments will be
 *   ignored).
 * @param $limit
 *   If non-zero, limit the size of the result set.
 *
 * @return
 *   An array of valid values in the form:
 *   array(
 *     key => value,
 *     ...
 *   )
 */
function _autocomplete_widgets_get_options($field, $string = '', $match = 'contains', $keys = NULL, $limit = NULL) {
  static $results = array();

  // Create unique id for static cache.
  if (!isset($keys) || !is_array($keys)) {
    $keys = array();
  }
  $cid = $field['field_name'] .':'. $match .':'. ($string !== '' ? $string : implode('-', $keys)) .':'. $limit;

  if (!isset($results[$cid])) {
    if ($field['widget']['type'] == 'autocomplete_widgets_allowvals') {
      $results[$cid] = _autocomplete_widgets_get_options_allowvals($field, $string, $match, $keys, $limit);
    }
    else if ($field['widget']['type'] == 'autocomplete_widgets_flddata') {
      $results[$cid] = _autocomplete_widgets_get_options_flddata($field, $string, $match, $keys, $limit);
    }
    else {
      $results[$cid] = array();
    }
  }

  return $results[$cid];
}

/**
 * Fetch an array of options for the given widget (allowed values).
 *
 * Options are retrieved from the allowed values defined for the field.
 */
function _autocomplete_widgets_get_options_allowvals($field, $string = '', $match = 'contains', $keys = NULL, $limit = NULL) {
  $function = $field['module'] .'_allowed_values';
  $allowed_values = (array)(function_exists($function) ? $function($field) : content_allowed_values($field));
  if (!isset($limit) || !is_numeric($limit)) {
    $limit = count($allowed_values);
  }
  $case_insensitive = (!empty($field['widget']['autocomplete_case']) ? FALSE : TRUE);
  if ($case_insensitive) {
    $string = drupal_strtolower($string);
  }
  $count = 0;
  $options = array();
  foreach ($allowed_values as $key => $value) {
    if ($string === '') {
      if (isset($keys) && is_array($keys)) {
        if (in_array($key, $keys)) {
          $options[$key] = $value;
          $count++;
        }
      }
      else {
        $options[$key] = $value;
        $count++;
      }
    }
    else if ($match == 'equals') {
      if ($value == $string) {
        $options[$key] = $value;
        $count++;
      }
    }
    else {
      $pos = strpos(($case_insensitive ? drupal_strtolower($value) : $value), $string);
      if (($match == 'starts_with' && $pos === 0) || ($match == 'contains' && $pos !== FALSE)) {
        $options[$key] = $value;
        $count++;
      }
    }
    if ($count >= $limit) {
      break;
    }
  }
  return $options;
}

/**
 * Fetch an array of options for the given widget (field data).
 *
 * Options are retrieved from existing values for the field.
 */
function _autocomplete_widgets_get_options_flddata($field, $string = '', $match = 'contains', $keys = NULL, $limit = NULL) {
  $db_info = content_database_info($field);
  $table = $db_info['table'];
  $column = $field['field_name'] .'_'. key($db_info['columns']);
  $where = array();
  $args = array();

  if ($string !== '') {
    $lower = (!empty($field['widget']['autocomplete_case']) || $match == 'equals' ? '' : 'LOWER');
    $match_operators = array(
      'contains' => "LIKE $lower('%%%s%%')",
      'equals' => "= '%s'",
      'starts_with' => "LIKE $lower('%s%%')",
    );
    $where[] = "$lower(f.". $column .') '. (isset($match_operators[$match]) ? $match_operators[$match] : $match_operators['contains']);
    $args[] = $string;
  }
  else if (isset($keys) && is_array($keys)) {
    $where[] = 'f.'. $column .' IN ('. db_placeholders($keys) .')';
    $args = array_merge($args, $keys);
  }

  $sql = 'SELECT f.'. $column .' FROM {'. $table .'} f WHERE '. implode(' AND ', $where) .' ORDER BY f.'. $column;
  if (!empty($field['widget']['i18n_flddata'])) {
    // Adding a join with the node table allows the i18n rewrite the query
    // to filter values from node for the proper language.
    $sql = db_rewrite_sql(str_replace(' WHERE ', ' INNER JOIN {node} n ON f.vid = n.vid WHERE ', $sql));
  }
  $result = $limit ? db_query_range($sql, $args, 0, $limit) : db_query($sql, $args);
  $options = array();
  while ($row = db_fetch_object($result)) {
    $options[$row->$column] = $row->$column;
  }

  return $options;
}

/**
 * Theme an individual textfield autocomplete element.
 */
function theme_autocomplete_widgets($element) {
  return $element['#children'];
}
